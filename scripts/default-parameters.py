import argparse
import datetime
import json
import pathlib
import typing

from eprempy import parameter
from eprempy import paths


_DB_PATH = parameter.SourceFile._db_path

_PY_PATH = _DB_PATH.parent / 'reference.py'


def main(
    source: paths.PathLike,
    append: bool=False,
    verbose: bool=False,
) -> None:
    """Generate default parameter values from EPREM source code."""
    basetypes_h = parameter.BaseTypesH(source)
    configuration_c = parameter.ConfigurationC(source)
    action = 'Appended' if append else 'Wrote'
    _generate_json(basetypes_h, configuration_c, _DB_PATH, append=append)
    if verbose:
        print(f"{action} new database to {_DB_PATH}")
    _generate_py(basetypes_h, configuration_c, _PY_PATH)
    if verbose:
        print(f"{action} new variables to {_PY_PATH}")


def _generate_json(
    basetypes_h: parameter.BaseTypesH,
    configuration_c: parameter.ConfigurationC,
    path: pathlib.Path,
    append: bool=False,
) -> None:
    """Generate the JSON database of default parameter values."""
    obj = {
        'BASETYPES_H': {**basetypes_h.todict('raw')},
        'CONFIGURATION_C': {**configuration_c.todict('raw')},
    }
    sources = {
        str(basetypes_h.origin),
        str(configuration_c.origin),
    }
    if append:
        with path.open('r') as rp:
            loaded = dict(json.load(rp))
        for k, v in obj.items():
            v.update(loaded.get(k, {}))
        if loaded['sources']:
            sources |= set(loaded['sources'])
    with path.open('w') as wp:
        json.dump(obj, wp, indent=4, sort_keys=True)
    srclog = path.parent / 'sources.log'
    _log_json_sources(srclog, sources)


_timestr = datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S')

_SOURCES_LOG_FOOTER = \
f'''This file is unversioned because it contains user-specific paths.
DO NOT commit this file to the repository.
'''


def _log_json_sources(path: pathlib.Path, sources: typing.Iterable[str]):
    """Create a log of the source files used in `_generate_json`."""
    lines = [
        'The following source files',
        '\n\n',
        '\n'.join(sources),
        '\n\n',
        'produced the current versions of',
        '\n\n',
        str(_PY_PATH),
        '\n',
        str(_DB_PATH),
        '\n\n',
        _SOURCES_LOG_FOOTER,
        '\n',
        f'Updated: {_timestr}',
        '\n',
    ]
    with path.open('w') as wp:
        wp.writelines(lines)


_FILE = pathlib.Path(__file__)


_DEFAULT_PY_DOC = \
f'''Default values and metadata for EPREM simulation parameters.

DO NOT EDIT THIS FILE. It was created via the {_FILE.name} CLI.
Run `python {_FILE} -h` for more information.
'''


_BASETYPES_H_DOC = \
'''Values and metadata for constants defined in `baseTypes.h`.

Each entry contains the numerical value (`'value'`), a brief description
(`'info'`), the metric unit (`'unit'`), and the built-in type (`'type'`) of each
defined constant.

Notes
-----
* A `'unit'` of `None` implies a non-physical parameter (e.g., a boolean flag or
  system path), whereas a `'unit'` of `'1'` implies a unitless physical
  parameter.

See Also
--------
`~runtime.Defaults`
    A mapping from parameter to default value, with value converted to its
    equivalent built-in type.

`~runtime.Interface`
    An aliased mapping from parameter to user-provided value, if available, or
    default value.
'''


_CONFIGURATION_C_DOC = \
'''Metadata for parameters defined in `configuration.c`.

Each entry contains the default value (`'default'`), the smallest acceptable
value ('`minimum`'), the largest acceptable value ('`maximum`'), as well as the
equivalent built-in type and metric unit of those values (`'type'` and
`'unit'`). Some entries also contain declared aliases for the parameter
('`aliases`').

Notes
-----
* This dictionary stores all values as strings because some values are defined
  with respect to others.
* A `'unit'` of `None` implies a non-physical parameter (e.g., a boolean flag or
  system path), whereas a `'unit'` of `'1'` implies a unitless physical
  parameter.

See Also
--------
`~runtime.Defaults`
    A mapping from parameter to default value, with value converted to its
    equivalent built-in type.

`~runtime.Interface`
    An aliased mapping from parameter to user-provided value, if available, or
    default value.
'''


def _generate_py(
    basetypes_h: parameter.BaseTypesH,
    configuration_c: parameter.ConfigurationC,
    path: pathlib.Path,
) -> None:
    """Generate the Python module of default parameter values."""
    lines = [
        f'"""\n{_DEFAULT_PY_DOC}"""\n',
        '\n\n',
        f"{basetypes_h.tostring(indent=4, sort=True, mode='full')}\n",
        f'"""{_BASETYPES_H_DOC}"""\n',
        '\n\n',
        f"{configuration_c.tostring(indent=4, sort=True, mode='full')}\n",
        f'"""{_CONFIGURATION_C_DOC}"""\n',
        '\n\n',
    ]
    with path.open('w') as fp:
        fp.writelines(lines)


if __name__ == '__main__':
    parser = argparse.ArgumentParser(
        description=main.__doc__,
        formatter_class=argparse.RawTextHelpFormatter,
    )
    parser.add_argument(
        '-s', '--source',
        help="use files in SRC to define default parameter values",
        metavar='SRC',
    )
    parser.add_argument(
        '--append',
        help="append parameters to the existing database (default: overwrite)",
        action='store_true',
    )
    parser.add_argument(
        '-v', '--verbose',
        help="print runtime messages",
        action='store_true',
    )
    args = parser.parse_args()
    main(**vars(args))
